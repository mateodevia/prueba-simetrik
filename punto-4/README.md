# Respuestas punto 4

## 1. ¿Porque no debería usar la libreria JQuery, si estoy usando ReactJS?

En primer lugar, porque no es necesario. Ambas son librerías de JavaScript que cumplen con el objetivo de permitirle al desarrollador interactuar con el DOM desde JavaScript. Por esta razón todas las cosas para las que uno usaría JQuery también se pueden lograr usando React. Por otro lado, se podría argumentar que JQuery ofrece otras funcionalidades importantes para el desarrollo de aplicaciones como los llamados AJAX. Sin embargo, estas pueden ser fácilmente remplazadas por APIs nativas del browser como fetch, o con paquetes de npm como axios.

En cuanto a desempeño, React está mejor optimizado que JQuery gracias a que mantiene en memoria una representación del DOM a la que se denomina el "Virtual DOM. Esto es mejor ya que el código que escribe el desarrollador modifica el Virtual DOM y no el DOM directamente. Cuando el Virtual DOM se modifica, React se encarga de ver qué cambió y solo actualizar en el DOM la parte que cambió. En contraste, JQuery permite que el desarrollador modifique directamente el DOM, lo que hace que la optimización dependa del desarrollador, lo cual difícilmente será mejor que la realizada por React. Adicionalmente, ambas librerías representan una carga adicional para la aplicación ya que son archivos que se tienen que cargar en la página, entonces tener ambas cargadas también deteriora el desempeño de la aplicación.

Por último, es importante destacar que React sigue un paradigma de programación declarativo. Esto significa que el desarrollador escribe código que especifica qué se desea que pase con la interfaz gráfica y no entra muy en detalle de cómo esto debe suceder ya que esto se lo delega a la herramienta. Estadísticamente se ha mostrado que la programación declarativa disminuye la cantidad de bugs en el código, y lo vuelve más mantenible. Por esta razón, muchos los lenguajes modernos se acercan cada vez más a la programación declarativa en vez de usar el paradigma imperativo.

## 2. ¿Porque usarias Hooks de las nuevas versiones de ReactJS, en lugar de class component?

Los Hooks fueron una actualización que hizo react para añadir las funcionalidades de estado y ciclo de vida a los functional components. Con esta nueva herramienta los functional components se vuelven equivalentes a los class componentes con algunos beneficios adicionales. El primer beneficio, y tal vez es el más notorio, es que los functional components con hooks son mucho menos verbosos que las clases, y gracias a esto, la cantidad de líneas de codigo necesarias para crear una funcionalidad con hooks es menor a la cantidad necesaria para crear la misma funcionalidad con clases.

Un segundo beneficio es el desempeño. Los class components al ser clases de JavaScript son mucho más pesados que los functional components ya que estos son esencialmente funciones de JavaScript.  También, al usar clases se debe lidiar con el objeto this, cuyo comportamiento en JavaScript es muy criticado en la comunidad de desarrollo. El this se pierde al pasar a otros componentes, lo que lleva a que toque hacer trabajo extra para que React se comporte adecuadamente. Por ejemplo, toca hacer bind del this en los event handlers para que el this de los handlers siga apuntando a la clase donde se definió y no donde se llamo, y asi, lograr tener acceso al estado. Esto además de retrasar el desarrollo, tambien puede introducir bugs en la aplicación que muchas veces son difíciles de encontrar.

Por último, se quiere resaltar que los hooks fomentan buenas prácticas en la escritura del código. Por ejemplo, cuando se usaban class components los life-cycle methods eran muy importantes ya que en ellos quedaba toda la lógica de los efectos secundarios. Consecuentemente, estas funciones eran muy extensos y dentro de ellos se encontraba lógica perteneciente a diferentes funcionalidades. Por el contrario, con el useEffect se puede separar esta lógica en diferentes efectos y manejar, por ejemplo, un efecto secundario para cada variable del estado por aparte, en vez de tener muchos ifs en el componentDidUpdate, o en el componentDidMount. Otro ejemplo, de cómo los hooks mejoran la calidad del código es el uso de custom hooks. En ellos, podemos codificar lógica que se reutilice en diferentes componentes en vez de replicarla en cada componente.

## 3. ¿Que es un archivo JSX?

Es un archivo de JavaScript con una sintaxis extendida usada para programar en React. La sintaxis extendida permite al desarrollador representar elementos HTML en el archivo JavaScript. Esta sintaxis se traduce a una representación en memoria del DOM conocida como Virtual DOM de la cual hablé en la pregunta 1. Con esta sintaxis se logran cosas como tener variables de JavaScript de tipo `<div>` o de tipo `<h1>` lo que por dentro solo se traduce a un objeto JavaScript que representa un `<div>` o un `<h1>`. Al tener estas representaciones lógicas de la interfaz gráfica, el desarrollo se vuelve mucho más intuitivo y flexible, ya que la lógica del funcionamiento y la lógica de presentación gráfica de pueden manejar en un solo lugar. Es importante aclarar que JSX no es necesario para usar React, pero si es la práctica más común que se encuentra en internet.

## 4. ¿Que diferencia hay entre una function y una arrow function de Javascript?
Una function es el tipo de función tradicional de JavaScript. Las cuales se pueden definir con nombre o sin nombre. La sintaxis de estas funciones es `function nombre() {...}` o `function() {...}` para las funciones anónimas. Las arrow functions son un nuevo tipo de función que salió en la actualización de EcmaScript 2015 (ES6) que es equivalente a las funciones normales pero que manejan el objeto `this` de forma distinta. Todas las funciones de JavaScript tienen acceso a una variable llamada `this`. Normalmente `this` hace referencia al objeto que invocó a la función. Este comportamiento es poco intuitivo para personas que vienen de otros lenguajes. Con las arrow functions `this` hace referencia al objeto en donde fueron definidas lo cual es más cercano al comportamiento de otros lenguajes.

Adicionalmente, las arrow functions ofrecen una sintaxis más simple que las funciones tradicionales, lo que hace que el código quede más limpio. La sintaxis de una arrow function es `() => {...}`. Sin embargo, esta se puede simplificar en algunos casos. Si solo tiene un parámetro, se puede eliminar los parentsis de la siguiente manera: `parametro => {...}`. Adicionalmente, si lo único que hace la función es retornar un valor, se puede eliminar los corchetes y la palabra return de la siguiente manera: `() => valorARetornar`.

## 5. ¿Que es Redux y cómo nos ayuda en los proyectos?
Redux es otra librería de JavaScript que se usa muy frecuente en React. Redux permite mantener un estado global en las aplicaciones el cual se puede acceder desde cualquier parte de la aplicación. Esta librería es muy útil en proyectos de React ya que React usa un modelo de jerarquía en la cual la información se pasa entre componentes a través de los props. Adicionalmente cada componente puede tener su estado propio para manejar información internamente. Aunque este modelo es intuitivo y funciona para cualquier aplicación, puede ser difícil de mantener cuando las aplicaciones crecen y la cantidad de información que se pasa entre los componentes es muy grande. Con Redux toda la información que es necesaria en varios de los componentes de la aplicación se pueden guardar en el store para que los componentes puedan acceder a ella sin necesidad de que sus padres se la pasen por props. De esta forma el código queda más organizado y es mucho más mantenible. Es importante aclarar que Redux no remplaza por completo las props y el estado de React, ya que pueden existir ciertas variables o estado que solo se necesite dentro de un componente y no valga la pena agregarla al estado de Redux.

## 6. ¿Que nos permite hacer la siguiente declaración?
`const anyFunction = (param_1) => (param_2) => param_1 + param_2`

Básicamente lo que tenemos aqui es una función que tiene un parametro param_1. Dicha función retorna otra función. La función retornada tiene un parametro param_2, y lo que hace la función es que retorna la suma de ambos parametros. Esto puede ser util si queremos definir param_1 en un momento dado, pero aun no conocemos param_2 y deseamos usar la función que los suma más adelante. En este caso podemos hacer lo siguiente:

`let sumFunction = anyFunction(1)`

y posteriormente cuando tengamos el valor del segundo parametro hacemos esto:

`let response = sumFunction(2)`

En este ejemplo response sería 3 ya que es el restltado de sumar 1 + 2.

Es importante aclarar que sumFunction tenia acceso al valor 1, gracias al clousure de JavaScript. El clousure hace que en sumFunction no solo se guarde la función como tal, sino tambien todas las variables a las cuales tenía acceso esa funcion en el momento que se creo. Por esto cuando se ejecuta sumFunction se sabe que param_1 tenía el valor de 1 por mas que esa variable ya no exista. 
